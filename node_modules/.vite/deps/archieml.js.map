{
  "version": 3,
  "sources": ["../../archieml/archieml.js"],
  "sourcesContent": ["\n\n// Structure inspired by John Resig's HTML parser\n// http://ejohn.org/blog/pure-javascript-html-parser/\n\n(function() {\n  'use strict';\n\n// The load function takes a string of text as its only argument.\n// It then proceeds to match the text to one of several regular expressions\n// which match patterns for different types of commands in AML.\nfunction load(input, options) {\n  var whitespacePattern = '\\\\u0000\\\\u0009\\\\u000A\\\\u000B\\\\u000C\\\\u000D\\\\u0020\\\\u00A0\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200A\\\\u200B\\\\u2028\\\\u2029\\\\u202F\\\\u205F\\\\u3000\\\\uFEFF';\n  var slugBlacklist = whitespacePattern + '\\\\u005B\\\\u005C\\\\u005D\\\\u007B\\\\u007D\\\\u003A';\n\n  var nextLine = new RegExp('.*((\\r|\\n)+)');\n  var startKey = new RegExp('^\\\\s*([^' + slugBlacklist + ']+)[ \\t\\r]*:[ \\t\\r]*(.*(?:\\n|\\r|$))');\n  var commandKey = new RegExp('^\\\\s*:[ \\t\\r]*(endskip|ignore|skip|end).*?(\\n|\\r|$)', 'i');\n  var arrayElement = new RegExp('^\\\\s*\\\\*[ \\t\\r]*(.*(?:\\n|\\r|$))');\n  var scopePattern = new RegExp('^\\\\s*(\\\\[|\\\\{)[ \\t\\r]*([\\+\\.]*)[ \\t\\r]*([^' + slugBlacklist + ']*)[ \\t\\r]*(?:\\\\]|\\\\}).*?(\\n|\\r|$)');\n\n  var data = {},\n      scope = data,\n\n      stack = [],\n      stackScope = undefined,\n\n      bufferScope = null,\n      bufferKey = null,\n      bufferString = '',\n\n      isSkipping = false;\n\n  var options = options || {};\n  if (options.comments !== true) options.comments = false;\n\n  while (input) {\n    // Inside the input stream loop, the `input` string is trimmed down as matches\n    // are found, and fires a call to the matching parse*() function.\n    var match;\n\n    if (commandKey.exec(input)) {\n      match = commandKey.exec(input);\n\n      parseCommandKey(match[1].toLowerCase());\n\n    } else if (!isSkipping && startKey.exec(input) &&\n        (!stackScope || stackScope.arrayType !== 'simple')) {\n      match = startKey.exec(input);\n\n      parseStartKey(match[1], match[2] || '');\n\n    } else if (!isSkipping && arrayElement.exec(input) && stackScope && stackScope.array &&\n        (stackScope.arrayType !== 'complex' && stackScope.arrayType !== 'freeform') &&\n        stackScope.flags.indexOf('+') < 0) {\n      match = arrayElement.exec(input);\n\n      parseArrayElement(match[1]);\n\n    } else if (!isSkipping && scopePattern.exec(input)) {\n      match = scopePattern.exec(input);\n\n      parseScope(match[1], match[2], match[3]);\n\n    } else if (nextLine.exec(input)) {\n      match = nextLine.exec(input);\n\n      parseText(match[0]);\n\n    } else {\n      // End of document reached\n      parseText(input);\n      input = '';\n    }\n\n    if (match) input = input.substring(match[0].length);\n  }\n\n  // The following parse functions add to the global `data` object and update\n  // scoping variables to keep track of what we're parsing.\n\n  function parseStartKey(key, restOfLine) {\n    // When a new key is encountered, the rest of the line is immediately added as\n    // its value, by calling `flushBuffer`.\n    flushBuffer();\n\n    incrementArrayElement(key);\n\n    if (stackScope && stackScope.flags.indexOf('+') > -1) key = 'value';\n\n    bufferKey = key;\n    bufferString = restOfLine;\n\n    flushBufferInto(key, {replace: true});\n  }\n\n  function parseArrayElement(value) {\n    flushBuffer();\n\n    stackScope.arrayType = stackScope.arrayType || 'simple';\n\n    stackScope.array.push('');\n    bufferKey = stackScope.array;\n    bufferString = value;\n    flushBufferInto(stackScope.array, {replace: true});\n  }\n\n  function parseCommandKey(command) {\n    // if isSkipping, don't parse any command unless :endskip\n\n    if (isSkipping && !(command === \"endskip\" || command === \"ignore\")) return flushBuffer();\n\n    switch (command) {\n      case \"end\":\n        // When we get to an end key, save whatever was in the buffer to the last\n        // active key.\n        if (bufferKey) flushBufferInto(bufferKey, {replace: false});\n        return;\n\n      case \"ignore\":\n        // When \":ignore\" is reached, stop parsing immediately\n        input = '';\n        break;\n\n      case \"skip\":\n        isSkipping = true;\n        break;\n\n      case \"endskip\":\n        isSkipping = false;\n        break;\n    }\n\n    flushBuffer();\n  }\n\n  function parseScope(scopeType, flags, scopeKey) {\n    // Throughout the parsing, `scope` refers to one of the following:\n    //   * `data`\n    //   * an object - one level within `data` - when we're within a {scope} block\n    //   * an object at the end of an array - which is one level within `data` -\n    //     when we're within an [array] block.\n    //\n    // `scope` changes whenever a scope key is encountered. It also changes\n    // within parseStartKey when we start a new object within an array.\n    flushBuffer();\n\n    if (scopeKey == '') {\n\n      // Move up a level\n      var lastStackItem = stack.pop();\n      scope = (lastStackItem ? lastStackItem.scope : data) || data\n      stackScope = stack[stack.length - 1];\n\n    } else if (scopeType === '[' || scopeType === '{') {\n      var nesting = false;\n      var keyScope = data;\n\n      // If the flags include \".\", drill down into the appropriate scope.\n      if (flags.indexOf('.') > -1) {\n        incrementArrayElement(scopeKey, flags);\n        nesting = true;\n        if (stackScope) keyScope = scope;\n\n      // Otherwise, make sure we reset to the global scope\n      } else {\n        scope = data;\n        stack = [];\n      }\n\n      // Within freeforms, the `type` of nested objects and arrays is taken\n      // verbatim from the `keyScope`.\n      if (stackScope && stackScope.flags.indexOf('+') > -1) {\n        var parsedScopeKey = scopeKey;\n\n      // Outside of freeforms, dot-notation interpreted as nested data.\n      } else {\n        var keyBits = scopeKey.split('.');\n        for (var i=0; i<keyBits.length - 1; i++) {\n          keyScope = keyScope[keyBits[i]] = keyScope[keyBits[i]] || {};\n        }\n        var parsedScopeKey = keyBits[keyBits.length - 1];\n      }\n\n      var stackScopeItem = {\n        array: null,\n        arrayType: null,\n        arrayFirstKey: null,\n        flags: flags,\n        scope: scope\n      };\n      \n      // Content of nested scopes within a freeform should be stored under \"value.\"\n      var isNestedFreeform = stackScope && stackScope.flags.indexOf('+') > -1 && flags.indexOf('.') > -1;\n\n      if (scopeType == '[') {\n        if (isNestedFreeform) parsedScopeKey = 'value'\n        stackScopeItem.array = keyScope[parsedScopeKey] = [];\n        if (flags.indexOf('+') > -1) stackScopeItem.arrayType = 'freeform';\n        if (nesting) {\n          stack.push(stackScopeItem);\n        } else {\n          stack = [stackScopeItem];\n        }\n        stackScope = stack[stack.length - 1];\n\n      } else if (scopeType == '{') {\n        if (nesting) {\n          if (isNestedFreeform) scope = scope.value = {};\n          else scope = keyScope[parsedScopeKey] = keyScope = {};\n          stack.push(stackScopeItem);\n        } else {\n          scope = keyScope[parsedScopeKey] = (typeof keyScope[parsedScopeKey] === 'object') ? keyScope[parsedScopeKey] : {};\n          stack = [stackScopeItem];\n        }\n        stackScope = stack[stack.length - 1];\n      }\n    }\n  }\n\n  function parseText(text) {\n    if (stackScope && stackScope.flags.indexOf('+') > -1 && text.match(/[^\\n\\r\\s]/)) {\n      stackScope.array.push({\"type\": \"text\", \"value\": text.replace(/(^\\s*)|(\\s*$)/g, '')});\n    } else {\n      bufferString += input.substring(0, text.length);\n    }\n  }\n\n  function incrementArrayElement(key) {\n    // Special handling for arrays. If this is the start of the array, remember\n    // which key was encountered first. If this is a duplicate encounter of\n    // that key, start a new object.\n\n    if (stackScope && stackScope.array) {\n      // If we're within a simple array, ignore\n      stackScope.arrayType = stackScope.arrayType || 'complex';\n      if (stackScope.arrayType === 'simple') return;\n\n      // arrayFirstKey may be either another key, or null\n      if (stackScope.arrayFirstKey === null || stackScope.arrayFirstKey === key) stackScope.array.push(scope = {});\n      if (stackScope.flags.indexOf('+') > -1) {\n        scope.type = key\n      } else {\n        stackScope.arrayFirstKey = stackScope.arrayFirstKey || key;\n      }\n    }\n  }\n\n  function formatValue(value, type) {\n    if (options.comments) {\n      value = value.replace(/(?:^\\\\)?\\[[^\\[\\]\\n\\r]*\\](?!\\])/mg, \"\"); // remove comments\n      value = value.replace(/\\[\\[([^\\[\\]\\n\\r]*)\\]\\]/g, \"[$1]\"); // [[]] => []\n    }\n\n    if (type == 'append') {\n      // If we're appending to a multi-line string, escape special punctuation\n      // by using a backslash at the beginning of any line.\n      // Note we do not do this processing for the first line of any value.\n      value = value.replace(new RegExp('^(\\\\s*)\\\\\\\\', 'gm'), \"$1\");\n    }\n\n    return value;\n  }\n\n  function flushBuffer() {\n    var result = bufferString + '';\n    bufferString = '';\n    bufferKey = null;\n    return result;\n  }\n\n  function flushBufferInto(key, options) {\n    options = options || {};\n    var existingBufferKey = bufferKey;\n    var value = flushBuffer();\n\n    if (options.replace) {\n      value = formatValue(value, 'replace').replace(new RegExp('^\\\\s*'), '');\n      bufferString = (new RegExp('\\\\s*$')).exec(value)[0];\n      bufferKey = existingBufferKey\n    } else {\n      value = formatValue(value, 'append');\n    }\n\n    if (typeof key === 'object') {\n      // key is an array\n      if (options.replace) key[key.length - 1] = '';\n\n      key[key.length - 1] += value.replace(new RegExp('\\\\s*$'), '');\n\n    } else {\n      var keyBits = key.split('.');\n      bufferScope = scope;\n\n      for (var i=0; i<keyBits.length - 1; i++) {\n        if (typeof bufferScope[keyBits[i]] === 'string') bufferScope[keyBits[i]] = {};\n        bufferScope = bufferScope[keyBits[i]] = bufferScope[keyBits[i]] || {};\n      }\n\n      if (options.replace) bufferScope[keyBits[keyBits.length - 1]] = '';\n\n      bufferScope[keyBits[keyBits.length - 1]] += value.replace(new RegExp('\\\\s*$'), '');\n    }\n  }\n\n  flushBuffer();\n  return data;\n}\n\nvar root = this;\nvar archieml = {load: load};\n\nif (typeof exports !== 'undefined') {\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = archieml;\n  }\n  exports.archieml = archieml;\n} else {\n  this.archieml = archieml;\n}\n\nif (typeof define === 'function' && define.amd) {\n  define('archieml', [], function() {\n    return archieml;\n  });\n}\n}.call(this))\n"],
  "mappings": "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",
  "names": ["options"]
}
